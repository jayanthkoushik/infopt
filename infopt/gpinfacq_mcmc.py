"""MCMC version of influence based acquisition for GP."""

from collections.abc import Iterator
from contextlib import AbstractContextManager

from GPyOpt.models.gpmodel import GPModel_MCMC  # pylint: disable=unused-import

from infopt.gpinfacq import GPInfAcq


class GPInfAcq_MCMC(GPInfAcq):

    """Influence based acquisition with averaging over hyperparameter samples.

    Arguments are the same as for AcquisitionLCB_MCMC.
    """

    analytical_gradient_prediction = True

    class InternalModelIterator(AbstractContextManager, Iterator):

        # pylint: disable=protected-access

        """Iterator over interal models generated by different
        hyperparameter samples.
        """

        def __init__(self, bomodel):
            self.bomodel = bomodel  # type: GPModel_MCMC
            self.ps = None
            self.iter = None

        def __enter__(self):
            self.ps = self.bomodel.model.param_array.copy()
            return self

        def __exit__(self, exc_type, exc_value, traceback):
            self.bomodel.model.param_array[:] = self.ps
            self.bomodel.model._trigger_params_changed()
            self.ps = None
            self.iter = None

        def __iter__(self):
            self.iter = iter(self.bomodel.hmc_samples)
            return self

        def __next__(self):
            s = next(self.iter)
            if self.bomodel.model._fixes_ is None:
                self.bomodel.model[:] = s
            else:
                self.bomodel.model[self.bomodel.model._fixes_] = s
            self.bomodel.model._trigger_params_changed()
            return self.bomodel.model

    @staticmethod
    def fromDict(model, space, optimizer, cost_withGradients, config):
        raise NotImplementedError()
